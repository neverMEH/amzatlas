import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import { GeneratedReport } from './report-generation-service'

export class PdfExportService {
  async generatePdf(report: GeneratedReport): Promise<Buffer> {
    // Create new PDF document
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    })

    // Set document properties
    doc.setProperties({
      title: report.configuration.name,
      subject: report.configuration.description || 'SQP Intelligence Report',
      author: 'SQP Intelligence',
      creator: 'SQP Intelligence Platform'
    })

    let yPosition = 20

    // Add header
    doc.setFontSize(24)
    doc.setTextColor(0, 102, 204) // Blue
    doc.text(report.configuration.name, 20, yPosition)
    yPosition += 10

    if (report.configuration.description) {
      doc.setFontSize(12)
      doc.setTextColor(100)
      doc.text(report.configuration.description, 20, yPosition)
      yPosition += 8
    }

    // Add metadata
    doc.setFontSize(10)
    doc.setTextColor(150)
    doc.text(`Generated: ${new Date(report.metadata.generated_at).toLocaleString()}`, 20, yPosition)
    yPosition += 5
    doc.text(`Period: ${new Date(report.metadata.period_start).toLocaleDateString()} - ${new Date(report.metadata.period_end).toLocaleDateString()}`, 20, yPosition)
    yPosition += 10

    // Add sections
    for (const section of report.sections) {
      // Check if we need a new page
      if (yPosition > 250) {
        doc.addPage()
        yPosition = 20
      }

      // Section title
      doc.setFontSize(16)
      doc.setTextColor(0, 102, 204)
      doc.text(section.title, 20, yPosition)
      yPosition += 8

      // Section content
      const sectionData = this.extractSectionData(section)
      
      if (sectionData && sectionData.length > 0) {
        // Create table
        const headers = Object.keys(sectionData[0])
        const rows = sectionData.map(item => 
          headers.map(header => {
            const value = item[header]
            if (typeof value === 'number') {
              return value.toLocaleString()
            }
            return String(value || '')
          })
        )

        // Add table with autoTable
        ;(doc as any).autoTable({
          startY: yPosition,
          head: [headers.map(h => h.replace(/_/g, ' ').toUpperCase())],
          body: rows.slice(0, 20), // Limit rows per section
          theme: 'striped',
          styles: {
            fontSize: 9,
            cellPadding: 2
          },
          headStyles: {
            fillColor: [0, 102, 204],
            textColor: 255
          },
          columnStyles: this.getColumnStyles(headers)
        })

        yPosition = (doc as any).lastAutoTable.finalY + 10
      } else if (section.data && typeof section.data === 'object') {
        // Handle summary data
        doc.setFontSize(10)
        doc.setTextColor(50)
        
        const summaryText = this.formatSummaryData(section.data)
        const lines = doc.splitTextToSize(summaryText, 170)
        doc.text(lines, 20, yPosition)
        yPosition += lines.length * 5 + 5
      }
    }

    // Add footer to all pages
    const pageCount = doc.getNumberOfPages()
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i)
      doc.setFontSize(8)
      doc.setTextColor(150)
      doc.text(
        'Generated by SQP Intelligence - Confidential',
        20,
        doc.internal.pageSize.height - 10
      )
      doc.text(
        `Page ${i} of ${pageCount}`,
        doc.internal.pageSize.width - 30,
        doc.internal.pageSize.height - 10
      )
    }

    // Convert to buffer
    const pdfOutput = doc.output('arraybuffer')
    return Buffer.from(pdfOutput)
  }

  private getColumnStyles(headers: string[]): Record<number, any> {
    const styles: Record<number, any> = {}
    
    headers.forEach((header, index) => {
      if (header.toLowerCase().includes('percent') || header.toLowerCase().includes('pct')) {
        styles[index] = { halign: 'right' }
      } else if (typeof header === 'number' || header.toLowerCase().includes('count') || header.toLowerCase().includes('sum')) {
        styles[index] = { halign: 'right' }
      }
    })
    
    return styles
  }

  private extractSectionData(section: any): any[] {
    const { data } = section
    
    if (!data) return []
    
    // Handle different data structures
    if (Array.isArray(data)) {
      return data
    }
    
    if (data.keywords && Array.isArray(data.keywords)) {
      return data.keywords
    }
    
    if (data.data && Array.isArray(data.data)) {
      return data.data
    }
    
    if (data.trends && Array.isArray(data.trends)) {
      return data.trends
    }
    
    if (data.anomalies && Array.isArray(data.anomalies)) {
      return data.anomalies
    }
    
    return []
  }

  private formatSummaryData(data: any): string {
    const lines: string[] = []
    
    if (data.total_impressions !== undefined) {
      lines.push(`Total Impressions: ${data.total_impressions.toLocaleString()}`)
    }
    if (data.total_clicks !== undefined) {
      lines.push(`Total Clicks: ${data.total_clicks.toLocaleString()}`)
    }
    if (data.total_purchases !== undefined) {
      lines.push(`Total Purchases: ${data.total_purchases.toLocaleString()}`)
    }
    if (data.total_revenue !== undefined) {
      lines.push(`Total Revenue: $${data.total_revenue.toLocaleString()}`)
    }
    
    if (data.key_insights && Array.isArray(data.key_insights)) {
      lines.push('\nKey Insights:')
      data.key_insights.forEach((insight: string) => {
        lines.push(`â€¢ ${insight}`)
      })
    }
    
    return lines.join('\n')
  }
}

export const pdfExportService = new PdfExportService()